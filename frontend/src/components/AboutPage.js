export default function AboutPage(){

    return(
        <div className="about">
            <h1>What I Learned Making a Chess App in React</h1>
            <p className="about-text">I first became interested in chess during the early stages of the Covid-19 pandemic. Coincidentally, this was around the same time that I began to fall in love with computer science and all the problem solving that it entails. Chess and computer science have a long history with one another, and one that I was eager to learn more about.</p>
            <p className="about-text">Chess ability has long served as a signifier of computer intelligence. It is a game that most people are familiar with and one that requires complex thinking and analysis to excel. Thus, it is only natural that computer intelligence could be tested by their abilities at chess.</p>
            <p className="about-text">In Stanley Kubrick’s science fiction masterpiece 2001: A Space Odyssey, a scene where astronaut Frank Poole is defeated in chess by supercomputer HAL 9000 is one of the first indications that the computer intelligence in the world of the film has outpaced that of humans. This scene also foreshadows the troubling implications of AI super-intelligence portrayed later in the film, but I don’t think I need to worry about my chess engine taking over a spaceship right now.</p>
            <img src="https://miro.medium.com/max/1400/0*mENZO11Wn6kK44qD" height="350px" width="600px"/>
            <p className="about-text">In 1996, IBM’s Deep Blue became the first computer program to defeat a world champion, Garry Kasparov, in a match under tournament regulations. This victory heralded a new era of computer chess, and of chess in general. Once computers learned from human chess players, now human chess players are learning from computers.</p>
            <img src="https://miro.medium.com/max/1400/0*PlODBjBpIxUgSH0P.jpg" height="350px" width="600px"/>
            <p className="about-text">For my final project at the Flatiron School bootcamp, I wanted to understand how chess computers really “thought” and how one could be created. I’m happy to say that I succeeded in creating a chess engine, along with an algorithm visualization tool, a user interface and account creation with authorization using a React frontend and Ruby on Rails backend. I am extremely pleased with how it turned out.</p>
            <h3 className="about-text">Libraries</h3>
            <p className="about-text">Two JavaScript libraries were instrumental for me in designing and creating this chess app. The first, Chess.js, was crucial for generating legal moves and storing game data. As its readme states, the library is used for “basically everything but the AI.” Chess.js allowed me to focus my efforts on what I was most interested in, which was the AI itself.</p>
            <p className="about-text">React-Chessboard, a library and component for React, not only allowed for a beautiful looking chessboard embedded into the website, but also drag and drop functionality for user moves. Like Chess.js, this library made it possible for me to focus on what I wanted to focus on.</p>
            <p className="about-text">Of course, working with third-party libraries does not always make all things easier. Some of the largest challenges I faced in this project concerned figuring out exactly how these libraries worked, how they stored game data, and how I could connect them with my own algorithms. Thankfully, I was able to overcome these challenges and integrate these libraries into my project.</p>
            <h3 className="about-text">Minimax Algorithm</h3>
            <p className="about-text">The main algorithm used in my chess engine is the Minimax algorithm, a classic algorithm used in game theory. The basic idea of the minimax algorithm is to select the move where you (the computer) are best off if your opponent makes the best possible move in response, thereby minimizing your maximum loss. In chess, the gain/loss is given by an evaluation function for a certain position which returns a number where the higher the number, the better it is for white, and the lower (reaching into the negatives) the number, the better it is for black. So, if white is moving using the minimax algorithm, they will make the move which guarantees a position with the highest possible evaluation number, where black would move looking to guarantee the lowest possible number.</p>
            <p className="about-text">The code for this algorithm essentially works as a recursive depth-first-search, where the initial position is called with a given depth variable, and the potential continuations are called at depth-1, until the base case of depth=0 is reached, at which point the evaluation function is called. This essentially creates a tree data structure, for which I created a visualization in my chess app. This visualization was created by storing child positions and their data in a hash map and recursively creating React components for each of these positions. The size of the tree, even at a relatively low engine depth like 3, is too large to be displayed effectively on one web page, so I added a scroll bar for each level of the tree and buttons to show or hide children of each position node.</p>
            <img src="https://miro.medium.com/max/1400/0*neUKuPMGY2KIMo0g" height="350px" width="600px"/>
            <h3 className="about-text">Alpha Beta Pruning</h3>
            <p className="about-text">Alpha-Beta Pruning is a technique that reduces unnecessary work in the minimax function. By storing the best value for a move that has already been found, it can skip potential continuations that are guaranteed to result in a suboptimal outcome for the computer. This pruning is achieved simply by adding two more parameters to the minimax function (alpha and beta), which represent the best values that the maximizer (white) and minimizer (black) can respectively achieve, and then adding conditional logic to break from iterating through moves when beta is greater than or equal to alpha, indicating that a better move has already been found and that this particular branch of the tree is not worthwhile to explore. Thus, utilizing alpha-beta pruning speeds up the processing time of a chess engine.</p>
            <h3 className="about-text">Evaluation Function</h3>
            <p className="about-text">No matter how good your minimax algorithm and alpha-beta pruning are, they are worthless without a competent evaluation function, which gives a numerical score to a given chess position.</p>
            <p className="about-text">David Levy writes in How Computers Play Chess, “No two programs have the same scoring function, but most take into account material balance, factors concerned with pawn structure, mobility, king safety, center control… [and more]”</p>
            <p className="about-text">My evaluation function is based on the value of pieces for each side (i.e. material balance), as well as a boost for pieces based on their “sight”, meaning how many squares a piece could hypothetically move to from the square they are on. For example, a knight can move to eight other squares from a position in the center of the board, but only two from a corner square.</p>
            <p className="about-text">I also included a slight boost for progressing pawns down the board in order to incentivize pawn promotion (where a pawn can be upgraded to a queen or other piece of the player’s choosing).</p>
            <p className="about-text">These factors are not totally comprehensive, as there are dozens of potential aspects of a position that could be included, but they provide a good starting point and create a computer that can punish human mistakes with ease.</p>
            <h3 className="about-text">Next Steps</h3>
            <p className="about-text">This project is one that I really fell in love with, and one that I never want to consider complete. Chess computing, like computer science in general, is a constantly evolving field, and the strength of computer programs has grown exponentially in the last several decades. There are several additions that I am planning to add to my chess engine.</p>
            <i className="about-text">Position Hashing</i>
            <p className="about-text">Position hashing refers to storing the evaluations of certain positions so that when they are encountered again by the computer, they can look up the evaluation of a position in constant time rather than running the evaluation function again.</p>
            <i className="about-text">A More Comprehensive Evaluation Function</i>
            <p className="about-text">While I am happy with how my chess engine performs against human opponents, the evaluation function could be made more comprehensive and sophisticated. Considerations of king safety and pawn structure, which are currently absent, are first on my list of potential additions.</p>
            <i className="about-text">Machine Learning</i>
            <p className="about-text">This may be part of a whole new project entirely, but the latest frontier of chess computing is more complex artificial intelligence and machine learning. One of the best chess engines now, AlphaZero, was trained only by playing itself to create a neural network. This field is fascinating to me and one that I would love to explore.</p>
            <h3 className="about-text">Closing Thoughts</h3>
            <p className="about-text">Building this chess engine was a wonderful experience, and one that has given me a better grasp of both chess and computer science algorithms, as well as React and Rails. I can’t wait to continue learning about this topic and to keep improving this engine.</p>
        </div>
    )
}